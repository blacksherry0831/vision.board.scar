
#include "axi.h"

volatile int  *g_uiFPGA       	= (int *)(0x80000000U);
volatile int  *g_uiDDR3   		= (int *)(0x60000000U);//512M空间可用
int            g_uiLocalTime     = 0U;
unsigned int   g_uiFd            = -1;
unsigned char *g_virtual_addr     = NULL;
int FPGA_CONVERT_DONE=FALSE;

//函数说明:地址拓展，10位地址拓展成12位地址
//输入:无
//输出:无
int AXILitemmap(int Addr)
{
    g_uiFd = open(MEM_DEV, O_RDWR|O_SYNC);
    if(g_uiFd < 0)
    {
        printf("open %s failed!\n",MEM_DEV);
        return -1;
    }
    // 按页存储，不能超过4k（1页），（ 0x1000）
    g_virtual_addr = mmap(NULL, 0x1000 , PROT_READ | PROT_WRITE, MAP_SHARED, g_uiFd, Addr);
    if(g_virtual_addr == NULL)
    {
        printf("mmap failed!\n");
        return -1;
    }

    return 0;
}

////函数说明:物理地址映射虚拟地址，注意 4K 边界
////输入:略
////输出:略
//unsigned char* UserAddr_mmap(int Addr)
//{
//	unsigned char *pc_virtual_addr;
//	unsigned int  uiFd;
//
//	uiFd = open(MEM_DEV, O_RDWR|O_SYNC);
//    if(uiFd < 0)
//    {
//        printf("open %s failed!\n",MEM_DEV);
//        return NULL;
//    }
//    // 按页存储，不能超过4k（1页），（ 0x1000）
//    pc_virtual_addr = mmap(NULL, 0x1000 , PROT_READ | PROT_WRITE, MAP_SHARED, uiFd, Addr);
//    if(pc_virtual_addr == NULL)
//    {
//        printf("mmap failed!\n");
//        return NULL;
//    }
//
//    return pc_virtual_addr;
//}
//
////函数说明:释放地址映射
////输入:略
////输出:略
//void UserAddr_unmmap(unsigned char* pc_virtual_addr)
//{
//
//   if(NULL != pc_virtual_addr){
//	   munmap(pc_virtual_addr, 0x1000);
//	   pc_virtual_addr = NULL;
//   }
//
//   if(g_uiFd >= 0)
//   {
//	   close(g_uiFd);
//   }
//
//   return ;
//}

//函数说明:地址拓展，10位地址拓展成12位地址
//输入:无
//输出:无
void AXILiteunmmap(void)
{

   if(NULL != g_virtual_addr){
	   munmap(g_virtual_addr, 0x1000);
	   g_virtual_addr = NULL;
   }

   if(g_uiFd >= 0)
   {
	   close(g_uiFd);
   }

   return ;
}

//函数说明:地址拓展，10位地址拓展成12位地址
//输入:无
//输出:无
void AXILitetoUser(int virtual_addr,int phy_addr,unsigned char *p_ucData,int Size)
{
    if(Size > 0x10000)
    {
        printf("Size is out!\n");
        return;
    }
	int i;
   if((phy_addr >= 0x80000000)&&(phy_addr < 0x90000000))
   {
		*(unsigned int*)(virtual_addr) = 0xAAAA5555;
		*(unsigned int*)(virtual_addr) = phy_addr;
		*(unsigned int*)(virtual_addr) = *(unsigned int*)p_ucData;
		*(unsigned int*)(virtual_addr) = 0x5555AAAA;
   }
   else if((phy_addr >= 0x40000000)&&(phy_addr < 0x80000000))
   {
	  for(i=0;i<Size/4;i++){
		  *(unsigned int*)(virtual_addr+i*4) = *(unsigned int*)(p_ucData+i*4);
	  }
   }else{
	   printf("Address not used!\n");
   }

   return;
}

//函数说明:地址拓展，10位地址拓展成12位地址
//输入:无
//输出:无
void UsertoAXILite(int virtual_addr,int phy_addr,unsigned char *p_ucData,int Size)
{
    if(Size > 0x10000)
    {
        printf("Size is out!\n");
        return;
    }

	int i;

   if((phy_addr >= 0x80000000)&&(phy_addr < 0x90000000))
   {
	   *(unsigned int*)p_ucData = *(volatile unsigned int*)(virtual_addr);
   }
   else if((phy_addr >= 0x40000000)&&(phy_addr < 0x80000000))
   {
	  for(i=0;i<Size/4;i++){
		  *(unsigned int*)(p_ucData+i*4) = *(volatile unsigned int*)(virtual_addr+i*4);
	  }
   }else{
	   printf("Address not used!\n");
   }
   return;
}
/*-----------------------------------*/
/**
 *
 */
/*-----------------------------------*/
//函数功能：向PL端 outside 模块发送控制参数
// 0x100: 复位 outside 模块
// 0x101: 数据模式 - 0x0正常模式 sensor的数据， 0x1内部测试模块数据， 0x2全零测试数据
// 0x102: 触发工作 - 先发 0x1 再发送 0x0
// 0x103: 工作模式 - 0x0 求和、平方和  0x1 求奇异点

void outside_send(int addr, int* pidata)
{
	AXILitemmap(PL_PARA_ADDR_BASE);
	AXILitetoUser(g_virtual_addr+addr,PL_PARA_ADDR_BASE+addr/4,pidata,sizeof(int));
	AXILiteunmmap();
}

void outside_read(int addr, int* pidata)
{
	AXILitemmap(PL_PARA_ADDR_BASE);
	UsertoAXILite(g_virtual_addr+addr,PL_PARA_ADDR_BASE+addr/4,pidata,sizeof(int));
	AXILiteunmmap();
}

unsigned char* pl_ddr3_read(int addr, unsigned char *pcArray, int uiLength)
{
	AXILitemmap(PL_DDR3_ADDR_BASE+addr);
	UsertoAXILite(g_virtual_addr,PL_DDR3_ADDR_BASE,pcArray,uiLength);
	AXILiteunmmap();

	return pcArray;
}

void pl_ddr3_write(int addr, unsigned char *pcArray, int uiLength)
{
	AXILitemmap(PL_DDR3_ADDR_BASE+addr);
	AXILitetoUser(g_virtual_addr,PL_DDR3_ADDR_BASE,pcArray,uiLength);
	AXILiteunmmap();
}

//**********************************************
// FPGA初始化
//**********************************************
void init_fpga()
{
	int  iTemp;
	int* piTemp=&iTemp;
	//**********************************************
	// 获取 sensor 状态，0xFF为正常，开始工作，否则退出
	//**********************************************
	outside_read(ADDR_SENSOR_STATE, piTemp);
	if(*piTemp!=0xff)
	{
		return;
	}
	//**********************************************
	// 获取 DDR@PL状态，ADDR_OUTSIDE_BUSY为1，退出
	//**********************************************
	outside_read(ADDR_OUTSIDE_BUSY, piTemp);
	if(*piTemp!=0x0)
	{
		return;
	}
	//**********************************************
	// 复位
	//**********************************************
	// 2.1 复位
	*piTemp=1;
	outside_send(ADDR_OUTSIDE_RESET,piTemp);
	*piTemp=0;
	outside_send(ADDR_OUTSIDE_RESET,piTemp);

}

//**********************************************
// 第一圈 -  求均值图
//**********************************************
void outside_first()
{
	int  iTemp;
	int* piTemp=&iTemp;

	// 数据模式
//	*piTemp=1;	//递增数
//	*piTemp=0;	//求和
	*piTemp=2;	//全0
	outside_send(ADDR_OUTSIDE_DATA_MODE,piTemp);
	// 工作模式
	*piTemp=0;	// 正常图像
	outside_send(ADDR_OUTSIDE_WORK_MODE,piTemp);
	// 3.3 触发工作
	*piTemp=1;
	outside_send(ADDR_OUTSIDE_START_EN,piTemp);
	*piTemp=0;
	outside_send(ADDR_OUTSIDE_START_EN,piTemp);
	// 3.4 等待完成
	*piTemp=1;
	while(*piTemp==1)
	{
		outside_read(ADDR_OUTSIDE_BUSY, piTemp);
	}
}


//**********************************************
// 第二圈 -  求奇异值图
//**********************************************
void outside_second()
{
	unsigned char *pucRdData=NULL;
	extern unsigned char PlImg[2073600];
	int  iTemp;
	int* piTemp=&iTemp;
	unsigned char Chn_num=0;
	unsigned int Img_base_Addr=0,blk_num=0;

	//**********************************************
	// 1 - 获取 sensor 状态，0xFF为正常
	//**********************************************
	outside_read(ADDR_SENSOR_STATE, piTemp);
	if(*piTemp!=0xff)
	{
		return;
	}

	//**********************************************
	// 2 - 等待空闲
	//**********************************************
	outside_read(ADDR_OUTSIDE_BUSY, piTemp);
	if(*piTemp!=0x0)
	{
		return;
	}

	//**********************************************
	// 3 - 复位
	//**********************************************
	*piTemp=1;
	outside_send(ADDR_OUTSIDE_RESET,piTemp);
	*piTemp=0;
	outside_send(ADDR_OUTSIDE_RESET,piTemp);

//**********************************************
// 4 - 设置工作模式
//**********************************************
	// 正常模式
//	*piTemp=1;	//递增数
	*piTemp=0;	//原始图像
	outside_send(ADDR_OUTSIDE_DATA_MODE,piTemp);

//	*piTemp=0;	// 求奇异值
	*piTemp=1;	// 求奇异值
	outside_send(ADDR_OUTSIDE_WORK_MODE,piTemp);


//**********************************************
// 5 - 触发工作 （脉冲）
//**********************************************
	*piTemp=1;
	outside_send(ADDR_OUTSIDE_START_EN,piTemp);
	*piTemp=0;
	outside_send(ADDR_OUTSIDE_START_EN,piTemp);
	// 等待完成
	TIME_START();
	*piTemp=1;
	while(*piTemp==1)
	{
		outside_read(ADDR_OUTSIDE_BUSY, piTemp);
	}
	TIME_END("B");
//**********************************************
// 6 - 轮询8同道 并发送图像 （4K模式）
//**********************************************
	for(Chn_num=0;Chn_num<8;Chn_num++)
	{
		Img_base_Addr=1920*1080*8+Chn_num*0x8000000;

		// 存储数据
		for(blk_num=0;blk_num<506;blk_num++)
		{
			pucRdData = pl_ddr3_read(Img_base_Addr+4096*blk_num, (unsigned char*)PlImg+4096*blk_num, 4096);
		}

		pucRdData = pl_ddr3_read(Img_base_Addr+4096*blk_num, (unsigned char*)PlImg+4096*blk_num, 1024);
	}
	return;
}
/*-----------------------------------*/
/**
 *
 */
/*-----------------------------------*/
void *axi_test_server(void* _pdata)
{

	init_fpga();
	outside_first();
	while(TRUE){
		outside_second();
			//sleep(10);
	}

	pthread_exit(NULL);

}
/*-----------------------------------*/
/**
 *
 */
/*-----------------------------------*/
pthread_t init_axi_server(void *_data)
{
	pthread_t _thread_tid;
	if( pthread_create(&_thread_tid, NULL, axi_test_server, _data) ){
			printf(" Create print_thread1 thread error!\n");
			exit(0);
	}
 return _thread_tid;
}
/*-----------------------------------*/
/**
 *
 */
/*-----------------------------------*/
