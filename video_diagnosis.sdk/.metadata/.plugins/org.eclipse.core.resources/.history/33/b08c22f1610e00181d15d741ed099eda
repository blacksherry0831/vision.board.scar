#include "main.h"
#include "interrupt_zynq.h"


INTC          IntcInstancePtr;
volatile u32  *g_uiFPGA       	= (u32 *)M_GP1_BRAM_BADDR;
volatile u32  *g_uiDDR   		= (u32 *)(0x01000000);//496M空间可用
volatile u32  *g_uiDDR3   		= (u32 *)(0x60000000);//512M空间可用
u32           g_uiLocalTime     = 0U;
u32           g_uiRampingpang0  = 0U;//(Fn+1-Fn)
u32           g_uiRampingpang1  = 0U;//(Fn+1-Fn)^2
u32           g_uiDDRpingpang0  = 0U;//对应一副图像数据地址的标记

//函数说明:系统工作主流程
//输入:无
//输出:无
int main(void)
{
	init_platform();
	SetupIntrSystem(&IntcInstancePtr,INTR_ID);
	XScuGic_Disable(&IntcInstancePtr,INTR_ID);//AXILitetoUser调用时需要关闭中断函数
	AXILitetoUser(RAM_TESTADDR,1);//ram测试开关
	AXILitetoUser(RAM_SELADDR,1);//ram选择器
	AXILitetoUser(INTR_PRTADDR,10000000);//中断周期100us
	AXILitetoUser(INTR_PWADDR,200);//中断信号脉冲宽度
	AXILitetoUser(0x290,0);//ram选择器
	//dma_test
	dma_test();
	AXILitetoUser(RAM_TESTADDR,0);//ram测试开关,1:测试，0:图像传输
	XScuGic_Enable(&IntcInstancePtr, INTR_ID);//AXILitetoUser调用结束时打开中断函数




    while(1){
    	//-----------------------------------------图像操作地址分配---------------------------------------------------------
    	//g_uiDDRpingpang0				(Fn+1-Fn)							(Fn+1-Fn)^2
    	//0                     g_uiDDR+DDR_PICTRUE00ADDR					g_uiDDR+DDR_PICTRUE01ADDR
    	//1						g_uiDDR+DDR_PICTRUE00ADDR+PICTRUE_SIZEADDR 	g_uiDDR+DDR_PICTRUE01ADDR+PICTRUE_SIZEADDR
    	//------------------------------------------------------------------------------------------------------------
//    	AXILitetoUser(INTR_PRTADDR,10000);//中断周期100us
//    	AXILitetoUser(INTR_PWADDR,200);//中断信号脉冲宽度
    	//算法实现
	}
	/* never reached */
	cleanup_platform();
    return 0;
}



//函数说明:100uS定时器中断处理函数
//输入:无
//输出:无
int fpga_timer_interrupt(void)
{
    int i;
	pictrue_transport_task();

	if(g_uiLocalTime%100 == 10){
//		printf("\nThis time is %d*100uS!",(int)(g_uiLocalTime));
//		printf("\nThis time is (%d,%d)!", (int)(g_uiLocalTime),(int)(g_uiFPGA[0x094]));
		for(i=0;i<52000;i++)
		    printf("\n%u", *(g_uiDDR + DDR_PICTRUE00ADDR + i));
	}
	g_uiLocalTime++;
	return 0;

}

//函数说明:1mS定时器中断处理函数
//输入:无
//输出:无
int pictrue_transport_task(void)
{

    u32 uiPictureAddr,uiDDRAddr;
//	u32 is_busy;
//	printf("\nThis time is (%d,%d)!",(int)(g_uiLocalTime),(int)(g_uiFPGA[0x094]));
    //(Fn+1-Fn)传输
    uiPictureAddr = g_uiFPGA[RAM0_STATUSADDR];
	if(g_uiRampingpang0 != (uiPictureAddr>>30)){//Fn+1-Fn传输时间到
		//用于启动乒乓传输
		g_uiRampingpang0 = (uiPictureAddr>>30);
		//ram选择器
		AXILitetoUser(RAM_SELADDR,1);
		//一副图像的当前地址
		uiPictureAddr    = uiPictureAddr&0xFFFFF;
		uiDDRAddr        = (u32)(g_uiDDR);
		uiDDRAddr       += DDR_PICTRUE00ADDR;
		uiDDRAddr       += PICTRUE_SIZEADDR*g_uiDDRpingpang0;
		uiDDRAddr       += ((uiPictureAddr>>15))<<16;
		//is write over
//		is_busy = Xil_In32(S_ACP_DMA_BADDR);
//	 	while(is_busy!=0x00020000) {
//	 		is_busy   = Xil_In32(S_ACP_DMA_BADDR);
//	 	}
	 	Xil_Out32(S_ACP_DMA_BADDR,    0x00020000);
		//write daddr
	 	Xil_Out32(S_ACP_DMA_BADDR+0x18,uiDDRAddr);
	 	//write start
	 	Xil_Out32(S_ACP_DMA_BADDR,    0x00010000);

//	 	printf("\nThis time is (%d,%d)!",(int)(g_uiLocalTime),(int)(g_uiFPGA[0x094]));
	}
	//(Fn+1-Fn)^2传输
	uiPictureAddr = g_uiFPGA[RAM1_STATUSADDR];
	if(g_uiRampingpang1 != (uiPictureAddr>>30)){//Fn+1-Fn传输时间到
		//用于启动乒乓传输
		g_uiRampingpang1 = (uiPictureAddr>>30);
		//ram选择器
		AXILitetoUser(RAM_SELADDR,2);
		//一副图像的当前地址
		uiPictureAddr    = uiPictureAddr&0xFFFFF;
		uiDDRAddr        = (u32)(g_uiDDR);
		uiDDRAddr       += DDR_PICTRUE01ADDR;
		uiDDRAddr       += PICTRUE_SIZEADDR*g_uiDDRpingpang0;
		uiDDRAddr       += ((uiPictureAddr>>15))<<16;
		//is write over
//		is_busy = Xil_In32(S_ACP_DMA_BADDR);
//	 	while(is_busy!=0x00020000) {
//	 		is_busy   = Xil_In32(S_ACP_DMA_BADDR);
//	 	}
	 	Xil_Out32(S_ACP_DMA_BADDR,    0x00020000);
		//write daddr
	 	Xil_Out32(S_ACP_DMA_BADDR+0x18,uiDDRAddr);
	 	//write start
	 	Xil_Out32(S_ACP_DMA_BADDR,    0x00010000);
	}

// 	if((g_uiDDRpingpang0 !=((uiPictureAddr&0xFFFFF)>>17))){
// 		g_uiDDRpingpang0  = (uiPictureAddr&0xFFFFF)>>17;
// 		printf("\nThis time is (%d,%d,%o)!",(int)(g_uiLocalTime),(int)((uiPictureAddr&0xFFFFF)>>17),(int)(uiPictureAddr&0xFFFFF));
// 	}
	return 0;
}


//函数说明:地址拓展，10位地址拓展成12位地址
//输入:无     
//输出:无
void AXILitetoUser(u32 Addr,u32 Data)
{
	g_uiFPGA[GTX0_WDATAADDR] = 0xAAAA5555;
	g_uiFPGA[GTX0_WDATAADDR] = Addr;
	g_uiFPGA[GTX0_WDATAADDR] = Data;
	g_uiFPGA[GTX0_WDATAADDR] = 0x5555AAAA;
	return;
}


