#include "tcp_server.h"

unsigned int socket_struct_len = sizeof(struct sockaddr_in);





struct filename{
		unsigned char data_file[32];
		unsigned char len_file[32];
		unsigned char index;
	};

static struct filename filename_config[]= {
		{"tcp_data.txt", "tcp_len.txt", TCP_PROTOCOL},
		{"udp_data.txt", "udp_len.txt", UDP_PROTOCOL},
		{"ip_data.txt", "ip_len.txt", IP_PROTOCOL},
};

pthread_t pthread1,pthread2,pthread3;
volatile unsigned char process_alive = TRUE;



unsigned char tcp_data[BUFLEN]={0};
char udp_data[BUFLEN]={0};
char ip_data[BUFLEN]={0};

char target_addr[20] = {0};
int target_port = 0;
char server_addr[20] = {0};
int server_port = 0;

char send_data[BUFLEN]={0};

unsigned int tcp_len=0;
unsigned int udp_len=0;
unsigned int ip_len=0;

//★★★★★★★★★★★★★★传输变量定义★★★★★★★★★★★★★★★
#define IWIDTH 1920
#define IHEIGHT 1080
#define Amax 2001
#define Qmax 10000
#define FRAME_SIZE (5)
unsigned char image_1_frame[FRAME_SIZE][1920*1080];
unsigned char image_1_frame_cal[1][1920*1080];
unsigned long image_1_frame_offset[FRAME_SIZE]={0};
signed char image_1_frame_status[FRAME_SIZE]={0};
unsigned int  image_current=0;
//☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆

union position{
	unsigned long lpos;
	unsigned char cpos[4];
	}pos;

/*TCP客户端初始化*/
int tcp_cfg_client(void)
{
    int clientfd;
    struct sockaddr_in *target = (struct sockaddr_in *)malloc(socket_struct_len);

    /*设置服务器地址*/
    target->sin_family = AF_INET;
    target->sin_port = htons(target_port);
    target->sin_addr.s_addr = inet_addr(target_addr);
    /*建立一个流式套接字*/
    clientfd = socket(AF_INET, SOCK_STREAM, 0);
    if(clientfd<0){
        printf("socket error\n");
        return -1;
    }
    /*连接服务器*/
    connect(clientfd,(struct sockaddr*)target,sizeof(*target));
    /*处理过程*/
    tcp_process_conn_client(clientfd);
    /*关闭连接*/
    close(clientfd);
    return 0;
}

/*TCP服务器初始化*/
void *tcp_cfg_server(void)
{
    struct sockaddr_in *server = (struct sockaddr_in *)malloc(socket_struct_len);
    struct sockaddr_in *client = (struct sockaddr_in *)malloc(socket_struct_len);
    unsigned int client_size = sizeof(*client);
    int clientfd;
    int sockfd;
    int err;
    int tmp = 1;

    /*设置服务器地址*/
    server->sin_family = AF_INET;
    server->sin_port = htons(8888);
    server->sin_addr.s_addr = inet_addr("192.168.100.102");
    /*建立一个流式套接字*/
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    /*一个端口释放后会等待两分钟之后才能再被使用，SO_REUSEADDR是让端口释放后立即就可以被再次使用*/
    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &tmp, sizeof(int));
    err = bind(sockfd, (struct sockaddr*)server, sizeof(*server));
    /*监听端口*/
    listen(sockfd, SOMAXCONN);/*侦听队列长度*/


    while(process_alive){

    		pthread_t _thread_ap_id;
    		int* volatile _clientfd_ptr=malloc(sizeof(int));
    		clientfd=*_clientfd_ptr = accept(sockfd, (struct sockaddr*)client, &client_size);
						if (clientfd < 0 || err != 0){
							printf("failed\n");
							close(sockfd);
							close(clientfd);
							free(server);
							free(client);
							pthread_exit(NULL);
						}
			printf("Connected to %s:%u\n",inet_ntoa(client->sin_addr),ntohs(client->sin_port));

			if(pthread_create(&_thread_ap_id,NULL,tcp_process_data,(void *)(_clientfd_ptr)) == -1){
				 fprintf(stderr,"pthread_create error!\n");
			}





    }

    close(sockfd);
    if(clientfd)
    close(clientfd);
    free(server);
    free(client);
    pthread_exit(NULL);

}
/*-----------------------------------*/
/**
 *
 */
/*-----------------------------------*/
pthread_t init_tcp_server(void *_data)
{
	pthread_t _thread_tid;
	if( pthread_create(&_thread_tid, NULL, tcp_cfg_server, _data) ){
			printf(" Create print_thread1 thread error!\n");
			exit(0);
	}
 return _thread_tid;
}

/*-----------------------------------*/


/*-----------------------------------*/
/*存储数据到文件中,上限2M,超出上限则从头开始覆盖*/
//void save_to_file(unsigned char index,char * data,unsigned int len)
//{
//		unsigned int residue_len=0;
//
//		FILE *dfp,*lfp;
//
//		dfp = fopen(filename_config[index].data_file,"r+");
//
//		lfp = fopen(filename_config[index].len_file,"rb+");
//
//		if((dfp == NULL)||(lfp == NULL))
//		{
//		 		perror("Error Number: ");
//		 		return;
//		}
//		else
//		{
//				fread(pos.cpos,1,4,lfp);
//				printf("file %s position start:%ld\n",filename_config[index].data_file,pos.lpos);
//				fclose(lfp);
//				fseek(dfp,pos.lpos,SEEK_SET);
//				if(pos.lpos + len > FILESIZE)
//				{
//						residue_len = pos.lpos + len - FILESIZE;
//						len -=  residue_len;
//				}
//				fwrite(data,1,len,dfp);
//				pos.lpos = ftell(dfp);
//
//				if(residue_len)
//				{
//						fseek(dfp,0,SEEK_SET);
//						printf("restart position is: %x\n",ftell(dfp));
//						fwrite(&data[len],1,residue_len,dfp);
//						pos.lpos = ftell(dfp);
//						printf("recover position is: %x\n",ftell(dfp));
//				}
//
//				lfp = fopen(filename_config[index].len_file,"wb+");
//
//				fwrite(pos.cpos,1,4,lfp);
//				printf("file %s position end:%ld\n",filename_config[index].data_file,pos.lpos);
//		}
//		fclose(dfp);
//		fclose(lfp);
//}

/*TCP客户端连接上服务器后的处理程序*/
void tcp_process_conn_client(int sc)
{
    int size=write(sc,send_data,strlen(send_data));
}


/*-----------------------------------*/
/**
 *
 */
/*-----------------------------------*/

void area_detect(unsigned char* Id,unsigned char* img_dst,int left,int top, int right ,int bottom)
{
	//IWIDTH 1920 IHEIGHT 1080
	int i=0,j=0,k=0,t=0;	//游标清零
	double Mn=0,Dn=0;
	extern unsigned char T[1080][1920];
	extern unsigned int Fcv[5];
	//中间结果向量初始化
	double HE[Amax],Lmun[Amax],Lmun2[Amax];	//计数器
	unsigned short q[Qmax][2];//队列
	memset(T,0,2073600);
	memset(HE,0,sizeof(double)*Amax);
	memset(Lmun,0,sizeof(double)*Amax);
	memset(Lmun2,0,sizeof(double)*Amax);
	memset(Lmun2,0,sizeof(double)*Amax);
	memset(q,0,sizeof(short)*Qmax);


	int Itmp=0,Itmpn=0;
	int idx=0,idxn=0;	// 张量索引
	int label=1;            //标记值初始化
	int queue_head=0;       //队头
	int queue_tail=0;       //队尾

	int pix[2]={0,0};
	int pixn[2]={0,0};
	int neighbour[8][2]={{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};  //8邻域坐标偏移列表

	for (i=top+1; i<bottom-1; i++)        // 防止越界
	{
		for (j=left+1; j<right-1; j++)     // 防止越界
		{
			idx=IHEIGHT*(j)+i;	// 张量到向量索引
			Itmp=(int)(*(Id+idx));
			// 若当前像素为1且未标记，计数器++，则赋予其当前标记值，对应坐标入队
			if (Itmp!=0 && T[i][j]==0)
			{
				if(label>Amax){
					Lmun[Amax]=Lmun[Amax]+1;
					HE[Amax]=HE[Amax]+Itmp;
				}else{
					Lmun[label]=Lmun[label]+1;
					HE[label]=HE[label]+Itmp;
				}
				T[i][j]=1;
				q[queue_tail][0]=i;
				q[queue_tail][1]=j;
				queue_tail=(queue_tail+1)%Qmax;
				// 队列空则退出递归
				while(queue_head!=queue_tail)
				{
					pix[0]=q[queue_head][0];pix[1]=q[queue_head][1];	// 取队首元素坐标
					for (k=0; k<8; k++)	// 搜索8邻域
					{
						pixn[0]=pix[0]+neighbour[k][0];pixn[1]=pix[1]+neighbour[k][1]; 	// 计算邻域元素坐标
						if (pixn[0]>=0 && pixn[0]<=IHEIGHT-1 && pixn[1] >=0 && pixn[1]<=IWIDTH-1)	//越界保护
						// 若当前邻域像素为1且未被标记，计数器++，则赋予其当前标记值，对应坐标入队
						{
							idxn=IHEIGHT*(pixn[1])+pixn[0];	// 张量到向量索引
							Itmpn=(int)(*(Id+idxn));
							if (Itmpn!=0 && T[pixn[0]][pixn[1]]==0 )
							{
								if(label>Amax){
									Lmun[Amax]=Lmun[Amax]+1;
									HE[Amax]=HE[Amax]+Itmpn;
								}else{
									Lmun[label]=Lmun[label]+1;
									HE[label]=HE[label]+Itmpn;
								}
								T[pixn[0]][pixn[1]]=1;
								q[queue_tail][0]=pixn[0];q[queue_tail][1]=pixn[1];
								queue_tail=(queue_tail+1)%Qmax;
							}
						}
					}
					queue_head=(queue_head+1)%Qmax;    // 遍历所有邻域像素后，队头元素出队
				}
				label=label+1;	// 标记值+1
				queue_head=0;	// 重置队头指针
				queue_tail=0;	// 重置队尾队头
			}
		}
	}

    if(label>Amax) //防越界
        {label=Amax;}
    for(t=1;t<label;t++)   //求平方项
        {
    	Lmun2[t]=Lmun[t]*Lmun[t];
    	Mn=Mn+Lmun[t];
    	Dn=Dn+Lmun2[t];
        }

    double thd=0,FM=0,FD=0,FV=0,Mns=0,Dns=0,Nsn=0,Ns=0;
	Mn= Mn/label;		// 标准均值
    Dn= Dn/label-Mn*Mn; // 标准标差 (∑V^2)/N-(∑V/N)^2
    thd=9*Dn-Mn*Mn;		// 阈值

    for (t=1;t<label;t++)   // 大面积奇异点 分类
    {
    	if( Lmun2[t]-2*Mn*Lmun[t]<thd )
       {
    		Ns=Ns+1;
            Mns=Mns+Lmun[t];
            Dns=Dns+Lmun2[t];
       }
       else
       {
    	   FV=FV+HE[t]/Lmun[t];
           Nsn=Nsn+Lmun[t];
       }
    }

	Mns=Mns/Ns;                 // 小区域均值
    Dns= sqrt(Dns/Ns-Mns*Mns);	// 小区域标差 (∑V^2)/N-(∑V/N)^2

    FM=abs(Mn-Mns)/Mns; // 小区域/连通区域 像素数均值比
    FD=Dns/Dn;          // 小区域/连通区域 像素数标差比
    FV=FV/Nsn/255;      // 大区域平均亮度差
    Fcv[0]=(unsigned int)(FM*1000000);
    Fcv[1]=(unsigned int)(FD*1000000);
    Fcv[2]=(unsigned int)(FV*1000000);
}

/*-----------------------------------*/
/**
 *
 */
/*-----------------------------------*/
void cal_image_part(unsigned char* img_src,unsigned char* img_dst,unsigned int* cal,const int WIDTH,const int HEIGHT,int left,int top, int right ,int bottom)
{

	int coli=left;
	int rowi=top;
	int i=0;
#if 0
	for(i=0;i<1920*1080;i++){
		*(img_dst+i)=img_src[cal[i]];
	}

#else
	for(coli=left;coli<right;coli++){
			for(rowi=top;rowi<bottom;rowi++){
				unsigned int idx=coli*1080+rowi;
				*(img_dst+idx)=img_src[cal[idx]];

		}
	}
#endif


}
/*-----------------------------------*/
/**
 *
 */
/*-----------------------------------*/

/*TCP服务器接受连接后的处理程序*/
int tcp_process_conn_server(int sc)
{
	// PL端DDR读取数据
	const int IMAGE_SIZE=1920*1080;
	extern unsigned char PlImg[8][2073600];
    int write_num=IMAGE_SIZE;

    unsigned char Chn_num=0;
    unsigned char *pucRdData=NULL;
    unsigned int Img_base_Addr=0,blk_num=0;
#if 1
//**********************************************
// 6 - 轮询8同道 并发送图像 （4K模式）
//**********************************************

	for(Chn_num=0;Chn_num<8;Chn_num++)
	{
		Img_base_Addr=1920*1080*8+Chn_num*0x8000000;

		// 存储数据
		for(blk_num=0;blk_num<506;blk_num++)
		{
			pucRdData = pl_ddr3_read(Img_base_Addr+4096*blk_num, (unsigned char*)PlImg[Chn_num]+4096*blk_num, 4096);
		}

		pucRdData = pl_ddr3_read(Img_base_Addr+4096*blk_num, (unsigned char*)PlImg[Chn_num]+4096*blk_num, 1024);

		unsigned char *Img_src=&PlImg[Chn_num][0];
		write_num=writen(sc,Img_src,IMAGE_SIZE);

		if(write_num!=IMAGE_SIZE){
			return 0;
		}

	}

#endif
#if 0
    while(FPGA_CONVERT_DONE==FALSE) sleep(0);

    for(chi=0;chi<8;chi++){

    	unsigned char *Img_src=&PlImg[chi][0];
		write_num=writen(sc,Img_src,IMAGE_SIZE);

    }

    FPGA_CONVERT_DONE=FALSE;
#endif




	return write_num==IMAGE_SIZE;
}

#if 0
/*TCP服务器接受连接后的处理程序*/
int tcp_process_conn_server(int sc)
{
	// 纠偏查找表
	extern short Irh[1920*1080];
	extern short Irw[1920*1080];
	extern unsigned int Irhw[1920*1080];
	extern unsigned char T[1080][1920];
	extern unsigned int Fcv[5];
	const int LEN = read(sc,tcp_data,BUFLEN);

	const int IDX0=image_current%FRAME_SIZE;
	const unsigned long OFFSET0=image_1_frame_offset[IDX0];
	const int _nLen=OFFSET0+LEN-1920*1080;
	const int _cLen=1920*1080-OFFSET0;
	unsigned char * DATA0=&image_1_frame[IDX0][OFFSET0];
	long t=0,i=0;
	if(LEN<=0) return LEN;

	if(_nLen<0){
		memcpy(DATA0,tcp_data,LEN);
		image_1_frame_offset[IDX0]+=LEN;
	}else{
		//one frame and next
		memcpy(DATA0,tcp_data,_cLen);
		image_1_frame_offset[IDX0]+=_cLen;
		image_1_frame_status[IDX0]=100;
		printf("now one frame ok !\n");

		// PL端DDR读取数据
		extern unsigned char PlImg[2073600];
		unsigned char *Img_src=&PlImg[0];


		write(sc,Img_src,2073600);

//★★★★★★★★★★★★★★★★★★★★★★★★★ 核心算法 ★★★★★★★★★★★★★★★★★★★★★★★★★
#if 0
		unsigned char *Img_dst=&image_1_frame_cal[0][0];
		IME_START();
		cal_image_part(Img_src,Img_dst,Irhw,1920,1080,0,0, 1920 ,1080);
		TIME_END("TIME COST");
		write(sc,Img_dst,2073600);
#endif
//<<<<<<<<<<纠偏		｜	检测>>>>>>>>>>>>
#if 0
		unsigned char *Img_dst=&T[0][0];
		unsigned int *FV = &Fcv[0];
		TIME_START();
		area_detect(Img_src,Img_dst,0,0, 1920 ,1080);
		TIME_END("TIME COST");
		FV[0]=1;
		write(sc,Img_dst,2073600);

//		write(sc,FV,20);
#endif
//☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆核心算法☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆



		//next
		int IDX1=(++image_current)%FRAME_SIZE;
		image_1_frame_offset[IDX1]=0;
		unsigned char * DATA1=&image_1_frame[IDX1][0];
		memcpy(DATA1,&tcp_data[_cLen],_nLen);
		image_1_frame_offset[IDX1]+=_nLen;
		image_1_frame_status[IDX1]=-1;

		printf("CH: %d,current data: %d\n",IDX1,image_1_frame_offset[IDX1]);

		int i=0;
		for(i=0;i<FRAME_SIZE;i++){
		printf("CHANNEL: %d, STATUS: %d\n",i,image_1_frame_status[i]);
		}
	}


	//printf("CH: %d,current data: %d\n",IDX0,image_1_frame_offset[IDX0]);
return LEN;
}
#endif

unsigned long TIMECOUNT=0;
void* tcp_process_data(void *data)
{
	int *_clientfd_p=(int*)data;
	printf(">>>>>>>>>>>>>>>>>>>>>>>>Thread START: %d!\n",++TIMECOUNT);

	while(TRUE){

		outside_second();

		int _Reslut=tcp_process_conn_server(*_clientfd_p);
		if(_Reslut==0){
			printf("Remote Socket is Close !");
			break;
		}

	}



	printf("<<<<<<<<<<<<<<<<<<<<<<<<<<Thread END: %d!\n",--TIMECOUNT);
	free(data);
	return (void*)0;
}


void SignHandler(int iSignNo)
{
    process_alive = FALSE;
}
/*
int main(int argc, char *argv[])
{
    int ret;
    pid_t pid;

    if(argc != 4 && argc != 5)
    {
        printf("Usage[server]:%s 0 [ip] [port]\n", argv[0]);
        printf("Usage[client]:%s 1 [ip] [port] [data]\n", argv[0]);
        return 0;
    }

    if(atoi(argv[1]) != 0 && atoi(argv[1]) != 1)
    {
        printf("argv[1] must be 0 or 1\n");
        printf("Usage:%s [server:0 or client:1] [ip] [port]\n", argv[0]);
        return 0;
    }

    signal(SIGKILL,SignHandler);

    if(atoi(argv[1]) == 0 && argc == 4)
    {
        server_port = atoi(argv[3]);
        if(strlen(argv[2]) < 20)
	     memcpy(server_addr, argv[2], strlen(argv[2]));

        ret = pthread_create(&pthread1, NULL, tcp_cfg_server, NULL);
        if(ret ==0)
        {
            pid = pthread_self();
            printf("Creat thread %lu sucess!!\nwaiting connect......\n",pid);
        }
        else
        {
            printf("Creat thread failed!!\n");
            exit(0);
        }

        pthread_join(pthread1, NULL);
    }

    if(atoi(argv[1]) == 1 && argc == 5)
    {
        target_port = atoi(argv[3]);
        if(strlen(argv[2]) < 20)
            memcpy(target_addr, argv[2], strlen(argv[2]));
        if(strlen(argv[4]) < BUFLEN)
            memcpy(send_data, argv[4], strlen(argv[4]));

        ret = pthread_create(&pthread2, NULL, tcp_cfg_client, NULL);
        if(ret ==0)
        {
            pid = pthread_self();
            printf("Creat thread %lu sucess!!\nwaiting connect......\n",pid);
        }
        else
        {
            printf("Creat thread failed!!\n");
            exit(0);
        }

        pthread_join(pthread2, NULL);
    }

    exit(0);
}
*/
