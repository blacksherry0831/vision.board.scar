// 应用程序
#include "linux_header.h"
#include "def.h"
#include "axi.h"
#include "tcp_server.h"




// 纠偏查找表
short Irh[1920*1080]={0};
short Irw[1920*1080]={0};
unsigned char T[1080][1920];
unsigned char PlImg[2073600];
unsigned int Irhw[1920*1080]={0};
unsigned int Fcv[5]={0};
int channel=0,Frame=0;


/*-----------------------------------*/
/**
 *
 */
/*-----------------------------------*/
void init_irh_irw()
{
	 unsigned int sum=0;
	// >>>>>>>>>>>>>>>>>>>>>>>>>> 文件系统 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
		FILE *fp;
		//★★★★★★★★★★★★★★读行纠偏数组★★★★★★★★★★★★★★★
		fp = fopen("/media/sdcard/Irh.txt","rb");
		sum=0;
		assert(fp!=0);
		fseek(fp,0L,SEEK_SET);
	    // 循环读取文件
	    while (1)
	    {
	//        // 清空缓冲区
	//        memset(Irh, 0, sizeof(Irh));
	        // 定义函数返回值
	        int rc = fread(Irh, sizeof(char), sizeof(Irh),fp);

	        // 读取到文件的结束，退出循环
	        if (rc <= 0)
	            break;
	        // 输出读取的结果到屏幕
	        sum+=rc;
	        printf("Irh is loaded %d !\n",sum);
	    }
	    // 关闭文件
	    fclose(fp);
	    //☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
		//★★★★★★★★★★★★★★读列纠偏数组★★★★★★★★★★★★★★★
		fp = fopen("/media/sdcard/Irw.txt","rb");
		sum=0;
		assert(fp!=0);
		fseek(fp,0L,SEEK_SET);
	    // 循环读取文件
	    while (1)
	    {
	//        // 清空缓冲区
	//        memset(Irw, 0, sizeof(Irw));
	        // 定义函数返回值
	        int rc = fread(Irw, sizeof(char), sizeof(Irw),fp);
	        // 读取到文件的结束，退出循环
	        if (rc <= 0)
	            break;
	        // 输出读取的结果到屏幕
	        sum+=rc;
	        printf("Irw is loaded %d !\n",sum);
	    }
	    // 关闭文件
	    fclose(fp);
	    //☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
#if 1
	    unsigned long const SIZE=1920*1080;
	    int i;
	    for (i=0;i<SIZE;i++){

	    	Irhw[i]=1080*(Irh[i]-1)+Irw[i]-1;
	    	assert(Irhw[i]>=0);
	    	assert(Irhw[i]<1920*1080);

	    }
#endif
}
/*-----------------------------------*/
/**
 *
 */
/*-----------------------------------*/
void test()
{

	int BITWIDTH=sizeof(void*);
	  printf("bit Width is :%d !\n",BITWIDTH*8);
}
/*-----------------------------------*/
/**
 *
 */
/*-----------------------------------*/
void test_memory()
{
		// >>>>>>>>>>>>>>>>>>>>>>>>>> 内存读写 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
int i;
		unsigned char ucWrite[4096]={0},ucRead[4096]={0};

		for (i=0;i<4096;i++)
		{
			ucWrite[i]=i;
		}

		//DDR3 Saddr1 Init
		for (i=0;i<4096;i++)
		{
			AXILitemmap(DDR3_ADDR+i*4096);
			AXILitetoUser((int)g_virtual_addr, DDR3_ADDR+i*4096,ucWrite,4096);
			UsertoAXILite((int)g_virtual_addr, DDR3_ADDR+i*4096,ucRead,4096);
			if(0 != memcmp(ucRead,ucWrite,1024))
			{
				printf("Error!\n");
			}
			AXILiteunmmap();
		}
		i=0;
		//<<<<<<<<<<<<<<<<<<<<<<<<<<<< 内存读写 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
}



//void pl_ddr3_test(void)
//{
//	unsigned char uiWrData[4096];
//	unsigned char uiRdData[4096];
//
//	unsigned char *pcTemp=NULL;
//
//	int   ii;
//	for(ii=0;ii<4096;ii++)
//	{
//		uiWrData[ii] = ii+1;
//		uiRdData[ii] = 0;
//	}
//
//	pl_ddr3_write(0, (unsigned char*)uiWrData, sizeof(uiWrData));
//
//	pcTemp = pl_ddr3_read(0, (unsigned char*)uiRdData, sizeof(uiRdData));
//
//	return;
//}
/*-----------------------------------*/
/**
 *
 */
/*-----------------------------------*/
//函数说明:系统工作主流程
//输入:无
//输出:无
int main(void)
{
	//extern unsigned char PlImg[2073600];
	////////////////////////////////////////////////////////////////////////////////////////
//	int PL_DDR3_ADDR_BASE=0x40000000;	//PL端 DDR3 地址空间起始地址
//	int PL_PARA_ADDR_BASE=0x80000000;

//	int iData=1;
//	int* piData=&iData;
//
//	AXILitemmap(PL_PARA_ADDR_BASE);
//	AXILitetoUser((int)g_virtual_addr+0x1000,PL_PARA_ADDR_BASE+0x800,piData,sizeof(int));
//	AXILiteunmmap();
	////////////////////////////////////////////////////////////////////////////////////////
//	test_memory();

	// 获取 pl ddr3 数据
	// void pl_ddr3_read(int addr, unsigned char* pcArray, int uiLength)

	//outside_test();
//	pl_ddr3_test();

//	while(1){};



	////////////////////////////////////////////////////////////////////////////////////////
//	test();
//	test_memory();
//	init_irh_irw();

	pthread_t thread1_tcp=init_tcp_server((void *)0);
	pthread_t thread1_axi=axi_test_server((void *)0);

	pthread_join(thread1_tcp,NULL);
	pthread_join(thread1_axi,NULL);

	do{
		sleep(100);
	}
    while(0);

    return 0;
}
